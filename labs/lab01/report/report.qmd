---
# Preamble

## Author
author:
  - name: Шубнякова Дарья НКНбд-01-22
    email: 1132226452@pfur.ru
    affiliation:
      - name: Российский университет дружбы народов
        country: Российская Федерация
        postal-code: 117198
        city: Москва
        address: ул. Миклухо-Маклая, д. 6

## Title
title: "Лабораторная работа №1"
subtitle: "Работа с git"
license: "CC BY"

## Generic options
lang: ru-RU
number-sections: true
toc: true
toc-title: "Содержание"
toc-depth: 2

## Formats
format:
  ### Pdf output format
  pdf:
    toc: true
    number-sections: true
    colorlinks: false
    toc-depth: 2
    documentclass: article
    papersize: a4
    fontsize: 12pt
    linestretch: 1.5
    babel-lang: russian
    babel-otherlangs: english
    indent: true
    header-includes: |
      \usepackage{indentfirst}
      \usepackage{float}
      \floatplacement{figure}{H}
      \usepackage{fontspec}
      \setmainfont{Times New Roman}
      \usepackage{titling}
      \renewcommand{\maketitlehooka}{\null\vfill}
      \renewcommand{\maketitlehookd}{\vfill\null\newpage}

  ### Docx output format
  docx:
    toc: true
    number-sections: true
    toc-depth: 2
---

\newpage

# Цель работы

Ознакомиться с работой git.

# Задание

Реализовать на практике команды и понять, как они работают.

# Теоретическое введение

Git — это распределённая система управления версиями (СКВ), созданная для отслеживания изменений в коде, координации работы множества разработчиков и управления различными версиями проектов. По сути, это как "машина времени" для вашего кода, позволяющая возвращаться к предыдущим состояниям проекта.

# Выполнение лабораторной работы

Установка имени и электронной почты. Параметры установки окончаний строк. Установка отображения unicode. Создаем страницу «Hello,World»([рис. @fig-001]).

![](image/1.png){#fig-001 width=70%}

Чтобы создать git репозиторий из этого каталога, выполняем команду git init. Добавим файл в репозиторий. Используем команду git status, чтобы проверить текущее состояние репозитория([рис. @fig-002]).

![](image/2.png){#fig-002 width=70%}

Добавим кое-какие HTML-теги к нашему приветствию. Меняем содержимое файла hello.html([рис. @fig-003]).

![](image/3.png){#fig-003 width=70%}

Сделаем коммит и проверим состояние.
git commit
Откроется редактор.
В первой строке вводим комментарий: «Added h1 tag». Сохраняем файл и выходим из редактора (для этого в редакторе по-умолчанию (Vim) вам нужно нажать клавишу ESC, ввести :wq и нажать Enter).
Теперь еще раз проверим состояние.
([рис. @fig-004]).

![](image/4.png){#fig-004 width=70%}

Изменяем страницу «Hello, World», чтобы она содержала стандартные теги <html> и <body>.([рис. @fig-005]).

![](image/5.png){#fig-005 width=70%}

Производим коммит проиндексированного изменения (значение по умолчанию), а затем еще раз проверяем состояние([рис. @fig-006]).

![](image/6.png){#fig-006 width=70%}

Сделали коммит второго изменения([рис. @fig-007]).

![](image/7.png){#fig-007 width=70%}

Затем проверяем содержимое файла hello.html. Создаем тег первой версии. Это версия c тегами <html> и <body>, но еще пока без <head>. Давайте сделаем ее версией v1-beta([рис. @fig-008]).

![](image/8.png){#fig-008 width=70%}

Внесем изменение в файл hello.html в виде нежелательного комментария.
([рис. @fig-009]).

![](image/9.png){#fig-009 width=70%}

Используем команду git checkout для переключения версии файла hello.html в репозитории.([рис. @fig-010]).

![](image/10.png){#fig-010 width=70%}

Проиндексируем это изменение.([рис. @fig-011]).

![](image/11.png){#fig-011 width=70%}

К счастью, вывод состояния показывает нам именно то, что мы должны сделать для отмены индексации изменения.
git reset HEAD hello.html([рис. @fig-012]).

![](image/12.png){#fig-012 width=70%}

Изменяем файл hello.html на следующий. Выполняем:
git add hello.html
git commit -m "Oops, we didn't want this commit"([рис. @fig-013]).

![](image/13.png){#fig-013 width=70%}

Чтобы отменить коммит, нам необходимо сделать коммит, который удаляет изме- нения, сохраненные нежелательным коммитом. Проверка лога показывает нежелательные и отмененные коммиты в наш репозиторий([рис. @fig-014]).

![](image/14.png){#fig-014 width=70%}

Но прежде чем удалить коммиты, давайте отметим последний коммит тегом, чтобы потом можно было его найти([рис. @fig-015]).

![](image/15.png){#fig-015 width=70%}

git tag oops([рис. @fig-016]).

![](image/16.png){#fig-016 width=70%}

Создаем директорию lib.([рис. @fig-017]).

![](image/17.png){#fig-017 width=70%}

Добавим в страницу комментарий автора (вставим свою фамилию)([рис. @fig-018]).

![](image/18.png){#fig-018 width=70%}

Выполним:
git add hello.html
git commit -m "Add an author comment".
Выполним:
ls -C .git/objects
Мы должны увидеть набор каталогов, имена которых состоят из 2 символов. Имена каталогов являются первыми двумя буквами хэша sha1 объекта, хранящегося в git.([рис. @fig-019]).

![](image/19.png){#fig-019 width=70%}

Выполним:
git log --max-count=1
Эта команда должна показать последний коммит в репозиторий. SHA1 хэш в вашей системе, вероятно, отличается от моего, но вы увидите что-то наподобие этого([рис. @fig-020]).

![](image/20.png){#fig-020 width=70%}

Давайте назовем нашу новую ветку «style». Выполним:
git checkout -b style([рис. @fig-021]).

![](image/21.png){#fig-021 width=70%}

Добавим файл стилей style.css([рис. @fig-022]).

![](image/22.png){#fig-022 width=70%}

Теперь в вашем проекте есть две ветки. Выполним:
git log --all([рис. @fig-023]).

![](image/23.png){#fig-023 width=70%}

git checkout master
cat lib/hello.html
Сейчас мы находимся на ветке master. Это заметно по тому, что файл hello.html не использует стили style.css([рис. @fig-024]).

![](image/24.png){#fig-024 width=70%}

Выполним:
git checkout style
cat lib/hello.html
Содержимое lib/hello.html подтверждает, что мы вернулись на ветку style.([рис. @fig-025]).

![](image/25.png){#fig-025 width=70%}

Выполним:
git log --graph --all
Добавление опции --graph в git log вызывает построение дерева коммитов с помощью простых ASCII символов.([рис. @fig-026]).

![](image/26.png){#fig-026 width=70%}

Слияние переносит изменения из двух веток в одну. Давайте вернемся к ветке style и сольем master с style.
Выполним:
git checkout style
git merge master
git log --graph --all([рис. @fig-027]).

![](image/27.png){#fig-027 width=70%}

Вернемся в ветку master и внесем изменения
git checkout master([рис. @fig-028]).

![](image/28.png){#fig-028 width=70%}

Используем команду rebase вместо команды merge. Мы вернулись в точку до пер- вого слияния и хотим перенести изменения из ветки master в нашу ветку style. На этот раз для переноса изменений из ветки master мы будем использовать команду git rebase вместо слияния([рис. @fig-029]).

![](image/29.png){#fig-029 width=70%}

Выполним:
git checkout master
git merge style
Поскольку последний коммит ветки master прямо предшествует последнему коммиту ветки style, git может выполнить ускоренное слияние-перемотку. При быстрой перемотке вперед git просто передвигает указатель вперед, таким обра- зом указывая на тот же коммит, что и ветка style.
При быстрой перемотке конфликтов быть не может([рис. @fig-030]).

![](image/30.png){#fig-030 width=70%}

Создадим клон репозитория. Выполним:
git clone hello cloned_hello
ls([рис. @fig-031]).

![](image/31.png){#fig-031 width=70%}

Мы увидели список всех файлов на верхнем уровне оригинального репозитория README.md, index.html и lib([рис. @fig-032]).

![](image/32.png){#fig-032 width=70%}

git remote
Мы видим, что клонированный репозиторий знает об имени по умолчанию удаленного репозитория. Давайте посмотрим, можем ли мы получить более подробную информацию об имени по умолчанию:
Выполним:
git remote show origin
Удаленные репозитории обычно размещаются на отдельной машине, возможно, централизованном сервере.([рис. @fig-033]).

![](image/33.png){#fig-033 width=70%}

Для того, чтобы увидеть все ветки, попробуем следующую команду:
git branch -a([рис. @fig-034]).

![](image/34.png){#fig-034 width=70%}

Внесем следующие изменения в файл README.md: Файл README.md
This is the Hello World example from the git tutorial.([рис. @fig-035]).

![](image/35.png){#fig-035 width=70%}

Выполним:
git branch --track style origin/style
git branch -a
git log --max-count=2([рис. @fig-036]).

![](image/36.png){#fig-036 width=70%}

Создаем чистый репозиторий
cd ..
git clone --bare hello hello.git
ls hello.git([рис. @fig-037]).

![](image/37.png){#fig-037 width=70%}

Файл README.md:
This is the Hello World example from the git tutorial.
(Changed in the original and pushed to shared)
Выполним:
git checkout master
git add README
git commit -m "Added shared comment to readme"([рис. @fig-038]).

![](image/38.png){#fig-038 width=70%}

Теперь отправим изменения в общий репозиторий. Выполним:
git push shared master
Выполним:
git remote add shared ../hello.git
git branch --track shared master
git pull shared master
cat README.md([рис. @fig-039]).

![](image/39.png){#fig-039 width=70%}

# Выводы

Мы настроили git и ознакомились со всеми полезными командами для дальнейшей работы.
